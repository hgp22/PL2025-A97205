Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DOWNTO
    MODOP

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMI declarations compound_stmt DOT
Rule 2     program -> PROGRAM ID SEMI compound_stmt DOT
Rule 3     declarations -> VAR var_decl_list
Rule 4     declarations -> empty
Rule 5     var_decl_list -> var_decl SEMI
Rule 6     var_decl_list -> var_decl SEMI var_decl_list
Rule 7     var_decl -> id_list COLON type
Rule 8     id_list -> ID
Rule 9     id_list -> ID COMMA id_list
Rule 10    type -> INTEGER
Rule 11    type -> BOOLEAN
Rule 12    compound_stmt -> BEGIN stmt_list END
Rule 13    stmt_list -> stmt
Rule 14    stmt_list -> stmt SEMI stmt_list
Rule 15    stmt -> assignment
Rule 16    stmt -> if_stmt
Rule 17    stmt -> while_stmt
Rule 18    stmt -> for_stmt
Rule 19    stmt -> readln_stmt
Rule 20    stmt -> writeln_stmt
Rule 21    stmt -> compound_stmt
Rule 22    stmt -> empty
Rule 23    assignment -> ID ASSIGN expr
Rule 24    if_stmt -> IF expr THEN stmt
Rule 25    if_stmt -> IF expr THEN stmt ELSE stmt
Rule 26    while_stmt -> WHILE expr DO stmt
Rule 27    for_stmt -> FOR ID ASSIGN expr TO expr DO stmt
Rule 28    readln_stmt -> READLN LPAREN ID RPAREN
Rule 29    writeln_stmt -> WRITELN LPAREN writeln_args RPAREN
Rule 30    writeln_stmt -> WRITE LPAREN writeln_args RPAREN
Rule 31    writeln_stmt -> WRITELN LPAREN RPAREN
Rule 32    writeln_stmt -> WRITE LPAREN RPAREN
Rule 33    writeln_args -> arg
Rule 34    writeln_args -> arg COMMA writeln_args
Rule 35    arg -> expr
Rule 36    arg -> STRING
Rule 37    expr -> simple_expr
Rule 38    expr -> simple_expr relop simple_expr
Rule 39    relop -> EQUAL
Rule 40    relop -> NOTEQUAL
Rule 41    relop -> LT
Rule 42    relop -> GT
Rule 43    relop -> LE
Rule 44    relop -> GE
Rule 45    simple_expr -> term
Rule 46    simple_expr -> simple_expr addop term
Rule 47    addop -> PLUS
Rule 48    addop -> MINUS
Rule 49    addop -> OR
Rule 50    term -> factor
Rule 51    term -> term mulop factor
Rule 52    mulop -> TIMES
Rule 53    mulop -> DIVIDE
Rule 54    mulop -> DIV
Rule 55    mulop -> MOD
Rule 56    mulop -> AND
Rule 57    factor -> ID
Rule 58    factor -> NUMBER
Rule 59    factor -> LPAREN expr RPAREN
Rule 60    factor -> NOT factor
Rule 61    factor -> TRUE
Rule 62    factor -> FALSE
Rule 63    factor -> MINUS factor
Rule 64    empty -> <empty>

Terminals, with rules where they appear

AND                  : 56
ASSIGN               : 23 27
BEGIN                : 12
BOOLEAN              : 11
COLON                : 7
COMMA                : 9 34
COMMENT              : 
DIV                  : 54
DIVIDE               : 53
DO                   : 26 27
DOT                  : 1 2
DOWNTO               : 
ELSE                 : 25
END                  : 12
EQUAL                : 39
FALSE                : 62
FOR                  : 27
GE                   : 44
GT                   : 42
ID                   : 1 2 8 9 23 27 28 57
IF                   : 24 25
INTEGER              : 10
LE                   : 43
LPAREN               : 28 29 30 31 32 59
LT                   : 41
MINUS                : 48 63
MOD                  : 55
MODOP                : 
NOT                  : 60
NOTEQUAL             : 40
NUMBER               : 58
OR                   : 49
PLUS                 : 47
PROGRAM              : 1 2
READLN               : 28
RPAREN               : 28 29 30 31 32 59
SEMI                 : 1 2 5 6 14
STRING               : 36
THEN                 : 24 25
TIMES                : 52
TO                   : 27
TRUE                 : 61
VAR                  : 3
WHILE                : 26
WRITE                : 30 32
WRITELN              : 29 31
error                : 

Nonterminals, with rules where they appear

addop                : 46
arg                  : 33 34
assignment           : 15
compound_stmt        : 1 2 21
declarations         : 1
empty                : 4 22
expr                 : 23 24 25 26 27 27 35 59
factor               : 50 51 60 63
for_stmt             : 18
id_list              : 7 9
if_stmt              : 16
mulop                : 51
program              : 0
readln_stmt          : 19
relop                : 38
simple_expr          : 37 38 38 46
stmt                 : 13 14 24 25 25 26 27
stmt_list            : 12 14
term                 : 45 46 51
type                 : 7
var_decl             : 5 6
var_decl_list        : 3 6
while_stmt           : 17
writeln_args         : 29 30 34
writeln_stmt         : 20

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMI declarations compound_stmt DOT
    (2) program -> . PROGRAM ID SEMI compound_stmt DOT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMI declarations compound_stmt DOT
    (2) program -> PROGRAM . ID SEMI compound_stmt DOT

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMI declarations compound_stmt DOT
    (2) program -> PROGRAM ID . SEMI compound_stmt DOT

    SEMI            shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMI . declarations compound_stmt DOT
    (2) program -> PROGRAM ID SEMI . compound_stmt DOT
    (3) declarations -> . VAR var_decl_list
    (4) declarations -> . empty
    (12) compound_stmt -> . BEGIN stmt_list END
    (64) empty -> .

  ! shift/reduce conflict for BEGIN resolved as shift
    VAR             shift and go to state 7
    BEGIN           shift and go to state 9

  ! BEGIN           [ reduce using rule 64 (empty -> .) ]

    declarations                   shift and go to state 5
    compound_stmt                  shift and go to state 6
    empty                          shift and go to state 8

state 5

    (1) program -> PROGRAM ID SEMI declarations . compound_stmt DOT
    (12) compound_stmt -> . BEGIN stmt_list END

    BEGIN           shift and go to state 9

    compound_stmt                  shift and go to state 10

state 6

    (2) program -> PROGRAM ID SEMI compound_stmt . DOT

    DOT             shift and go to state 11


state 7

    (3) declarations -> VAR . var_decl_list
    (5) var_decl_list -> . var_decl SEMI
    (6) var_decl_list -> . var_decl SEMI var_decl_list
    (7) var_decl -> . id_list COLON type
    (8) id_list -> . ID
    (9) id_list -> . ID COMMA id_list

    ID              shift and go to state 15

    var_decl_list                  shift and go to state 12
    var_decl                       shift and go to state 13
    id_list                        shift and go to state 14

state 8

    (4) declarations -> empty .

    BEGIN           reduce using rule 4 (declarations -> empty .)


state 9

    (12) compound_stmt -> BEGIN . stmt_list END
    (13) stmt_list -> . stmt
    (14) stmt_list -> . stmt SEMI stmt_list
    (15) stmt -> . assignment
    (16) stmt -> . if_stmt
    (17) stmt -> . while_stmt
    (18) stmt -> . for_stmt
    (19) stmt -> . readln_stmt
    (20) stmt -> . writeln_stmt
    (21) stmt -> . compound_stmt
    (22) stmt -> . empty
    (23) assignment -> . ID ASSIGN expr
    (24) if_stmt -> . IF expr THEN stmt
    (25) if_stmt -> . IF expr THEN stmt ELSE stmt
    (26) while_stmt -> . WHILE expr DO stmt
    (27) for_stmt -> . FOR ID ASSIGN expr TO expr DO stmt
    (28) readln_stmt -> . READLN LPAREN ID RPAREN
    (29) writeln_stmt -> . WRITELN LPAREN writeln_args RPAREN
    (30) writeln_stmt -> . WRITE LPAREN writeln_args RPAREN
    (31) writeln_stmt -> . WRITELN LPAREN RPAREN
    (32) writeln_stmt -> . WRITE LPAREN RPAREN
    (12) compound_stmt -> . BEGIN stmt_list END
    (64) empty -> .

    ID              shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    READLN          shift and go to state 30
    WRITELN         shift and go to state 31
    WRITE           shift and go to state 32
    BEGIN           shift and go to state 9
    SEMI            reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)

    stmt_list                      shift and go to state 16
    stmt                           shift and go to state 17
    assignment                     shift and go to state 18
    if_stmt                        shift and go to state 19
    while_stmt                     shift and go to state 20
    for_stmt                       shift and go to state 21
    readln_stmt                    shift and go to state 22
    writeln_stmt                   shift and go to state 23
    compound_stmt                  shift and go to state 24
    empty                          shift and go to state 25

state 10

    (1) program -> PROGRAM ID SEMI declarations compound_stmt . DOT

    DOT             shift and go to state 33


state 11

    (2) program -> PROGRAM ID SEMI compound_stmt DOT .

    $end            reduce using rule 2 (program -> PROGRAM ID SEMI compound_stmt DOT .)


state 12

    (3) declarations -> VAR var_decl_list .

    BEGIN           reduce using rule 3 (declarations -> VAR var_decl_list .)


state 13

    (5) var_decl_list -> var_decl . SEMI
    (6) var_decl_list -> var_decl . SEMI var_decl_list

    SEMI            shift and go to state 34


state 14

    (7) var_decl -> id_list . COLON type

    COLON           shift and go to state 35


state 15

    (8) id_list -> ID .
    (9) id_list -> ID . COMMA id_list

    COLON           reduce using rule 8 (id_list -> ID .)
    COMMA           shift and go to state 36


state 16

    (12) compound_stmt -> BEGIN stmt_list . END

    END             shift and go to state 37


state 17

    (13) stmt_list -> stmt .
    (14) stmt_list -> stmt . SEMI stmt_list

    END             reduce using rule 13 (stmt_list -> stmt .)
    SEMI            shift and go to state 38


state 18

    (15) stmt -> assignment .

    SEMI            reduce using rule 15 (stmt -> assignment .)
    END             reduce using rule 15 (stmt -> assignment .)
    ELSE            reduce using rule 15 (stmt -> assignment .)


state 19

    (16) stmt -> if_stmt .

    SEMI            reduce using rule 16 (stmt -> if_stmt .)
    END             reduce using rule 16 (stmt -> if_stmt .)
    ELSE            reduce using rule 16 (stmt -> if_stmt .)


state 20

    (17) stmt -> while_stmt .

    SEMI            reduce using rule 17 (stmt -> while_stmt .)
    END             reduce using rule 17 (stmt -> while_stmt .)
    ELSE            reduce using rule 17 (stmt -> while_stmt .)


state 21

    (18) stmt -> for_stmt .

    SEMI            reduce using rule 18 (stmt -> for_stmt .)
    END             reduce using rule 18 (stmt -> for_stmt .)
    ELSE            reduce using rule 18 (stmt -> for_stmt .)


state 22

    (19) stmt -> readln_stmt .

    SEMI            reduce using rule 19 (stmt -> readln_stmt .)
    END             reduce using rule 19 (stmt -> readln_stmt .)
    ELSE            reduce using rule 19 (stmt -> readln_stmt .)


state 23

    (20) stmt -> writeln_stmt .

    SEMI            reduce using rule 20 (stmt -> writeln_stmt .)
    END             reduce using rule 20 (stmt -> writeln_stmt .)
    ELSE            reduce using rule 20 (stmt -> writeln_stmt .)


state 24

    (21) stmt -> compound_stmt .

    SEMI            reduce using rule 21 (stmt -> compound_stmt .)
    END             reduce using rule 21 (stmt -> compound_stmt .)
    ELSE            reduce using rule 21 (stmt -> compound_stmt .)


state 25

    (22) stmt -> empty .

    SEMI            reduce using rule 22 (stmt -> empty .)
    END             reduce using rule 22 (stmt -> empty .)
    ELSE            reduce using rule 22 (stmt -> empty .)


state 26

    (23) assignment -> ID . ASSIGN expr

    ASSIGN          shift and go to state 39


state 27

    (24) if_stmt -> IF . expr THEN stmt
    (25) if_stmt -> IF . expr THEN stmt ELSE stmt
    (37) expr -> . simple_expr
    (38) expr -> . simple_expr relop simple_expr
    (45) simple_expr -> . term
    (46) simple_expr -> . simple_expr addop term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    expr                           shift and go to state 40
    simple_expr                    shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 28

    (26) while_stmt -> WHILE . expr DO stmt
    (37) expr -> . simple_expr
    (38) expr -> . simple_expr relop simple_expr
    (45) simple_expr -> . term
    (46) simple_expr -> . simple_expr addop term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    expr                           shift and go to state 51
    simple_expr                    shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 29

    (27) for_stmt -> FOR . ID ASSIGN expr TO expr DO stmt

    ID              shift and go to state 52


state 30

    (28) readln_stmt -> READLN . LPAREN ID RPAREN

    LPAREN          shift and go to state 53


state 31

    (29) writeln_stmt -> WRITELN . LPAREN writeln_args RPAREN
    (31) writeln_stmt -> WRITELN . LPAREN RPAREN

    LPAREN          shift and go to state 54


state 32

    (30) writeln_stmt -> WRITE . LPAREN writeln_args RPAREN
    (32) writeln_stmt -> WRITE . LPAREN RPAREN

    LPAREN          shift and go to state 55


state 33

    (1) program -> PROGRAM ID SEMI declarations compound_stmt DOT .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMI declarations compound_stmt DOT .)


state 34

    (5) var_decl_list -> var_decl SEMI .
    (6) var_decl_list -> var_decl SEMI . var_decl_list
    (5) var_decl_list -> . var_decl SEMI
    (6) var_decl_list -> . var_decl SEMI var_decl_list
    (7) var_decl -> . id_list COLON type
    (8) id_list -> . ID
    (9) id_list -> . ID COMMA id_list

    BEGIN           reduce using rule 5 (var_decl_list -> var_decl SEMI .)
    ID              shift and go to state 15

    var_decl                       shift and go to state 13
    var_decl_list                  shift and go to state 56
    id_list                        shift and go to state 14

state 35

    (7) var_decl -> id_list COLON . type
    (10) type -> . INTEGER
    (11) type -> . BOOLEAN

    INTEGER         shift and go to state 58
    BOOLEAN         shift and go to state 59

    type                           shift and go to state 57

state 36

    (9) id_list -> ID COMMA . id_list
    (8) id_list -> . ID
    (9) id_list -> . ID COMMA id_list

    ID              shift and go to state 15

    id_list                        shift and go to state 60

state 37

    (12) compound_stmt -> BEGIN stmt_list END .

    DOT             reduce using rule 12 (compound_stmt -> BEGIN stmt_list END .)
    SEMI            reduce using rule 12 (compound_stmt -> BEGIN stmt_list END .)
    END             reduce using rule 12 (compound_stmt -> BEGIN stmt_list END .)
    ELSE            reduce using rule 12 (compound_stmt -> BEGIN stmt_list END .)


state 38

    (14) stmt_list -> stmt SEMI . stmt_list
    (13) stmt_list -> . stmt
    (14) stmt_list -> . stmt SEMI stmt_list
    (15) stmt -> . assignment
    (16) stmt -> . if_stmt
    (17) stmt -> . while_stmt
    (18) stmt -> . for_stmt
    (19) stmt -> . readln_stmt
    (20) stmt -> . writeln_stmt
    (21) stmt -> . compound_stmt
    (22) stmt -> . empty
    (23) assignment -> . ID ASSIGN expr
    (24) if_stmt -> . IF expr THEN stmt
    (25) if_stmt -> . IF expr THEN stmt ELSE stmt
    (26) while_stmt -> . WHILE expr DO stmt
    (27) for_stmt -> . FOR ID ASSIGN expr TO expr DO stmt
    (28) readln_stmt -> . READLN LPAREN ID RPAREN
    (29) writeln_stmt -> . WRITELN LPAREN writeln_args RPAREN
    (30) writeln_stmt -> . WRITE LPAREN writeln_args RPAREN
    (31) writeln_stmt -> . WRITELN LPAREN RPAREN
    (32) writeln_stmt -> . WRITE LPAREN RPAREN
    (12) compound_stmt -> . BEGIN stmt_list END
    (64) empty -> .

    ID              shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    READLN          shift and go to state 30
    WRITELN         shift and go to state 31
    WRITE           shift and go to state 32
    BEGIN           shift and go to state 9
    SEMI            reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)

    stmt                           shift and go to state 17
    stmt_list                      shift and go to state 61
    assignment                     shift and go to state 18
    if_stmt                        shift and go to state 19
    while_stmt                     shift and go to state 20
    for_stmt                       shift and go to state 21
    readln_stmt                    shift and go to state 22
    writeln_stmt                   shift and go to state 23
    compound_stmt                  shift and go to state 24
    empty                          shift and go to state 25

state 39

    (23) assignment -> ID ASSIGN . expr
    (37) expr -> . simple_expr
    (38) expr -> . simple_expr relop simple_expr
    (45) simple_expr -> . term
    (46) simple_expr -> . simple_expr addop term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    expr                           shift and go to state 62
    simple_expr                    shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 40

    (24) if_stmt -> IF expr . THEN stmt
    (25) if_stmt -> IF expr . THEN stmt ELSE stmt

    THEN            shift and go to state 63


state 41

    (37) expr -> simple_expr .
    (38) expr -> simple_expr . relop simple_expr
    (46) simple_expr -> simple_expr . addop term
    (39) relop -> . EQUAL
    (40) relop -> . NOTEQUAL
    (41) relop -> . LT
    (42) relop -> . GT
    (43) relop -> . LE
    (44) relop -> . GE
    (47) addop -> . PLUS
    (48) addop -> . MINUS
    (49) addop -> . OR

    THEN            reduce using rule 37 (expr -> simple_expr .)
    DO              reduce using rule 37 (expr -> simple_expr .)
    SEMI            reduce using rule 37 (expr -> simple_expr .)
    END             reduce using rule 37 (expr -> simple_expr .)
    ELSE            reduce using rule 37 (expr -> simple_expr .)
    RPAREN          reduce using rule 37 (expr -> simple_expr .)
    COMMA           reduce using rule 37 (expr -> simple_expr .)
    TO              reduce using rule 37 (expr -> simple_expr .)
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    OR              shift and go to state 74

    relop                          shift and go to state 64
    addop                          shift and go to state 65

state 42

    (45) simple_expr -> term .
    (51) term -> term . mulop factor
    (52) mulop -> . TIMES
    (53) mulop -> . DIVIDE
    (54) mulop -> . DIV
    (55) mulop -> . MOD
    (56) mulop -> . AND

    EQUAL           reduce using rule 45 (simple_expr -> term .)
    NOTEQUAL        reduce using rule 45 (simple_expr -> term .)
    LT              reduce using rule 45 (simple_expr -> term .)
    GT              reduce using rule 45 (simple_expr -> term .)
    LE              reduce using rule 45 (simple_expr -> term .)
    GE              reduce using rule 45 (simple_expr -> term .)
    PLUS            reduce using rule 45 (simple_expr -> term .)
    MINUS           reduce using rule 45 (simple_expr -> term .)
    OR              reduce using rule 45 (simple_expr -> term .)
    THEN            reduce using rule 45 (simple_expr -> term .)
    DO              reduce using rule 45 (simple_expr -> term .)
    SEMI            reduce using rule 45 (simple_expr -> term .)
    END             reduce using rule 45 (simple_expr -> term .)
    ELSE            reduce using rule 45 (simple_expr -> term .)
    RPAREN          reduce using rule 45 (simple_expr -> term .)
    COMMA           reduce using rule 45 (simple_expr -> term .)
    TO              reduce using rule 45 (simple_expr -> term .)
    TIMES           shift and go to state 76
    DIVIDE          shift and go to state 77
    DIV             shift and go to state 78
    MOD             shift and go to state 79
    AND             shift and go to state 80

    mulop                          shift and go to state 75

state 43

    (50) term -> factor .

    TIMES           reduce using rule 50 (term -> factor .)
    DIVIDE          reduce using rule 50 (term -> factor .)
    DIV             reduce using rule 50 (term -> factor .)
    MOD             reduce using rule 50 (term -> factor .)
    AND             reduce using rule 50 (term -> factor .)
    EQUAL           reduce using rule 50 (term -> factor .)
    NOTEQUAL        reduce using rule 50 (term -> factor .)
    LT              reduce using rule 50 (term -> factor .)
    GT              reduce using rule 50 (term -> factor .)
    LE              reduce using rule 50 (term -> factor .)
    GE              reduce using rule 50 (term -> factor .)
    PLUS            reduce using rule 50 (term -> factor .)
    MINUS           reduce using rule 50 (term -> factor .)
    OR              reduce using rule 50 (term -> factor .)
    THEN            reduce using rule 50 (term -> factor .)
    DO              reduce using rule 50 (term -> factor .)
    SEMI            reduce using rule 50 (term -> factor .)
    END             reduce using rule 50 (term -> factor .)
    ELSE            reduce using rule 50 (term -> factor .)
    RPAREN          reduce using rule 50 (term -> factor .)
    COMMA           reduce using rule 50 (term -> factor .)
    TO              reduce using rule 50 (term -> factor .)


state 44

    (57) factor -> ID .

    TIMES           reduce using rule 57 (factor -> ID .)
    DIVIDE          reduce using rule 57 (factor -> ID .)
    DIV             reduce using rule 57 (factor -> ID .)
    MOD             reduce using rule 57 (factor -> ID .)
    AND             reduce using rule 57 (factor -> ID .)
    EQUAL           reduce using rule 57 (factor -> ID .)
    NOTEQUAL        reduce using rule 57 (factor -> ID .)
    LT              reduce using rule 57 (factor -> ID .)
    GT              reduce using rule 57 (factor -> ID .)
    LE              reduce using rule 57 (factor -> ID .)
    GE              reduce using rule 57 (factor -> ID .)
    PLUS            reduce using rule 57 (factor -> ID .)
    MINUS           reduce using rule 57 (factor -> ID .)
    OR              reduce using rule 57 (factor -> ID .)
    THEN            reduce using rule 57 (factor -> ID .)
    DO              reduce using rule 57 (factor -> ID .)
    SEMI            reduce using rule 57 (factor -> ID .)
    END             reduce using rule 57 (factor -> ID .)
    ELSE            reduce using rule 57 (factor -> ID .)
    RPAREN          reduce using rule 57 (factor -> ID .)
    COMMA           reduce using rule 57 (factor -> ID .)
    TO              reduce using rule 57 (factor -> ID .)


state 45

    (58) factor -> NUMBER .

    TIMES           reduce using rule 58 (factor -> NUMBER .)
    DIVIDE          reduce using rule 58 (factor -> NUMBER .)
    DIV             reduce using rule 58 (factor -> NUMBER .)
    MOD             reduce using rule 58 (factor -> NUMBER .)
    AND             reduce using rule 58 (factor -> NUMBER .)
    EQUAL           reduce using rule 58 (factor -> NUMBER .)
    NOTEQUAL        reduce using rule 58 (factor -> NUMBER .)
    LT              reduce using rule 58 (factor -> NUMBER .)
    GT              reduce using rule 58 (factor -> NUMBER .)
    LE              reduce using rule 58 (factor -> NUMBER .)
    GE              reduce using rule 58 (factor -> NUMBER .)
    PLUS            reduce using rule 58 (factor -> NUMBER .)
    MINUS           reduce using rule 58 (factor -> NUMBER .)
    OR              reduce using rule 58 (factor -> NUMBER .)
    THEN            reduce using rule 58 (factor -> NUMBER .)
    DO              reduce using rule 58 (factor -> NUMBER .)
    SEMI            reduce using rule 58 (factor -> NUMBER .)
    END             reduce using rule 58 (factor -> NUMBER .)
    ELSE            reduce using rule 58 (factor -> NUMBER .)
    RPAREN          reduce using rule 58 (factor -> NUMBER .)
    COMMA           reduce using rule 58 (factor -> NUMBER .)
    TO              reduce using rule 58 (factor -> NUMBER .)


state 46

    (59) factor -> LPAREN . expr RPAREN
    (37) expr -> . simple_expr
    (38) expr -> . simple_expr relop simple_expr
    (45) simple_expr -> . term
    (46) simple_expr -> . simple_expr addop term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    expr                           shift and go to state 81
    simple_expr                    shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 47

    (60) factor -> NOT . factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    factor                         shift and go to state 82

state 48

    (61) factor -> TRUE .

    TIMES           reduce using rule 61 (factor -> TRUE .)
    DIVIDE          reduce using rule 61 (factor -> TRUE .)
    DIV             reduce using rule 61 (factor -> TRUE .)
    MOD             reduce using rule 61 (factor -> TRUE .)
    AND             reduce using rule 61 (factor -> TRUE .)
    EQUAL           reduce using rule 61 (factor -> TRUE .)
    NOTEQUAL        reduce using rule 61 (factor -> TRUE .)
    LT              reduce using rule 61 (factor -> TRUE .)
    GT              reduce using rule 61 (factor -> TRUE .)
    LE              reduce using rule 61 (factor -> TRUE .)
    GE              reduce using rule 61 (factor -> TRUE .)
    PLUS            reduce using rule 61 (factor -> TRUE .)
    MINUS           reduce using rule 61 (factor -> TRUE .)
    OR              reduce using rule 61 (factor -> TRUE .)
    THEN            reduce using rule 61 (factor -> TRUE .)
    DO              reduce using rule 61 (factor -> TRUE .)
    SEMI            reduce using rule 61 (factor -> TRUE .)
    END             reduce using rule 61 (factor -> TRUE .)
    ELSE            reduce using rule 61 (factor -> TRUE .)
    RPAREN          reduce using rule 61 (factor -> TRUE .)
    COMMA           reduce using rule 61 (factor -> TRUE .)
    TO              reduce using rule 61 (factor -> TRUE .)


state 49

    (62) factor -> FALSE .

    TIMES           reduce using rule 62 (factor -> FALSE .)
    DIVIDE          reduce using rule 62 (factor -> FALSE .)
    DIV             reduce using rule 62 (factor -> FALSE .)
    MOD             reduce using rule 62 (factor -> FALSE .)
    AND             reduce using rule 62 (factor -> FALSE .)
    EQUAL           reduce using rule 62 (factor -> FALSE .)
    NOTEQUAL        reduce using rule 62 (factor -> FALSE .)
    LT              reduce using rule 62 (factor -> FALSE .)
    GT              reduce using rule 62 (factor -> FALSE .)
    LE              reduce using rule 62 (factor -> FALSE .)
    GE              reduce using rule 62 (factor -> FALSE .)
    PLUS            reduce using rule 62 (factor -> FALSE .)
    MINUS           reduce using rule 62 (factor -> FALSE .)
    OR              reduce using rule 62 (factor -> FALSE .)
    THEN            reduce using rule 62 (factor -> FALSE .)
    DO              reduce using rule 62 (factor -> FALSE .)
    SEMI            reduce using rule 62 (factor -> FALSE .)
    END             reduce using rule 62 (factor -> FALSE .)
    ELSE            reduce using rule 62 (factor -> FALSE .)
    RPAREN          reduce using rule 62 (factor -> FALSE .)
    COMMA           reduce using rule 62 (factor -> FALSE .)
    TO              reduce using rule 62 (factor -> FALSE .)


state 50

    (63) factor -> MINUS . factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    factor                         shift and go to state 83

state 51

    (26) while_stmt -> WHILE expr . DO stmt

    DO              shift and go to state 84


state 52

    (27) for_stmt -> FOR ID . ASSIGN expr TO expr DO stmt

    ASSIGN          shift and go to state 85


state 53

    (28) readln_stmt -> READLN LPAREN . ID RPAREN

    ID              shift and go to state 86


state 54

    (29) writeln_stmt -> WRITELN LPAREN . writeln_args RPAREN
    (31) writeln_stmt -> WRITELN LPAREN . RPAREN
    (33) writeln_args -> . arg
    (34) writeln_args -> . arg COMMA writeln_args
    (35) arg -> . expr
    (36) arg -> . STRING
    (37) expr -> . simple_expr
    (38) expr -> . simple_expr relop simple_expr
    (45) simple_expr -> . term
    (46) simple_expr -> . simple_expr addop term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    RPAREN          shift and go to state 88
    STRING          shift and go to state 91
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    writeln_args                   shift and go to state 87
    arg                            shift and go to state 89
    expr                           shift and go to state 90
    simple_expr                    shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 55

    (30) writeln_stmt -> WRITE LPAREN . writeln_args RPAREN
    (32) writeln_stmt -> WRITE LPAREN . RPAREN
    (33) writeln_args -> . arg
    (34) writeln_args -> . arg COMMA writeln_args
    (35) arg -> . expr
    (36) arg -> . STRING
    (37) expr -> . simple_expr
    (38) expr -> . simple_expr relop simple_expr
    (45) simple_expr -> . term
    (46) simple_expr -> . simple_expr addop term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    RPAREN          shift and go to state 93
    STRING          shift and go to state 91
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    writeln_args                   shift and go to state 92
    arg                            shift and go to state 89
    expr                           shift and go to state 90
    simple_expr                    shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 56

    (6) var_decl_list -> var_decl SEMI var_decl_list .

    BEGIN           reduce using rule 6 (var_decl_list -> var_decl SEMI var_decl_list .)


state 57

    (7) var_decl -> id_list COLON type .

    SEMI            reduce using rule 7 (var_decl -> id_list COLON type .)


state 58

    (10) type -> INTEGER .

    SEMI            reduce using rule 10 (type -> INTEGER .)


state 59

    (11) type -> BOOLEAN .

    SEMI            reduce using rule 11 (type -> BOOLEAN .)


state 60

    (9) id_list -> ID COMMA id_list .

    COLON           reduce using rule 9 (id_list -> ID COMMA id_list .)


state 61

    (14) stmt_list -> stmt SEMI stmt_list .

    END             reduce using rule 14 (stmt_list -> stmt SEMI stmt_list .)


state 62

    (23) assignment -> ID ASSIGN expr .

    SEMI            reduce using rule 23 (assignment -> ID ASSIGN expr .)
    END             reduce using rule 23 (assignment -> ID ASSIGN expr .)
    ELSE            reduce using rule 23 (assignment -> ID ASSIGN expr .)


state 63

    (24) if_stmt -> IF expr THEN . stmt
    (25) if_stmt -> IF expr THEN . stmt ELSE stmt
    (15) stmt -> . assignment
    (16) stmt -> . if_stmt
    (17) stmt -> . while_stmt
    (18) stmt -> . for_stmt
    (19) stmt -> . readln_stmt
    (20) stmt -> . writeln_stmt
    (21) stmt -> . compound_stmt
    (22) stmt -> . empty
    (23) assignment -> . ID ASSIGN expr
    (24) if_stmt -> . IF expr THEN stmt
    (25) if_stmt -> . IF expr THEN stmt ELSE stmt
    (26) while_stmt -> . WHILE expr DO stmt
    (27) for_stmt -> . FOR ID ASSIGN expr TO expr DO stmt
    (28) readln_stmt -> . READLN LPAREN ID RPAREN
    (29) writeln_stmt -> . WRITELN LPAREN writeln_args RPAREN
    (30) writeln_stmt -> . WRITE LPAREN writeln_args RPAREN
    (31) writeln_stmt -> . WRITELN LPAREN RPAREN
    (32) writeln_stmt -> . WRITE LPAREN RPAREN
    (12) compound_stmt -> . BEGIN stmt_list END
    (64) empty -> .

    ID              shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    READLN          shift and go to state 30
    WRITELN         shift and go to state 31
    WRITE           shift and go to state 32
    BEGIN           shift and go to state 9
    ELSE            reduce using rule 64 (empty -> .)
    SEMI            reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)

    stmt                           shift and go to state 94
    assignment                     shift and go to state 18
    if_stmt                        shift and go to state 19
    while_stmt                     shift and go to state 20
    for_stmt                       shift and go to state 21
    readln_stmt                    shift and go to state 22
    writeln_stmt                   shift and go to state 23
    compound_stmt                  shift and go to state 24
    empty                          shift and go to state 25

state 64

    (38) expr -> simple_expr relop . simple_expr
    (45) simple_expr -> . term
    (46) simple_expr -> . simple_expr addop term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    simple_expr                    shift and go to state 95
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 65

    (46) simple_expr -> simple_expr addop . term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    term                           shift and go to state 96
    factor                         shift and go to state 43

state 66

    (39) relop -> EQUAL .

    ID              reduce using rule 39 (relop -> EQUAL .)
    NUMBER          reduce using rule 39 (relop -> EQUAL .)
    LPAREN          reduce using rule 39 (relop -> EQUAL .)
    NOT             reduce using rule 39 (relop -> EQUAL .)
    TRUE            reduce using rule 39 (relop -> EQUAL .)
    FALSE           reduce using rule 39 (relop -> EQUAL .)
    MINUS           reduce using rule 39 (relop -> EQUAL .)


state 67

    (40) relop -> NOTEQUAL .

    ID              reduce using rule 40 (relop -> NOTEQUAL .)
    NUMBER          reduce using rule 40 (relop -> NOTEQUAL .)
    LPAREN          reduce using rule 40 (relop -> NOTEQUAL .)
    NOT             reduce using rule 40 (relop -> NOTEQUAL .)
    TRUE            reduce using rule 40 (relop -> NOTEQUAL .)
    FALSE           reduce using rule 40 (relop -> NOTEQUAL .)
    MINUS           reduce using rule 40 (relop -> NOTEQUAL .)


state 68

    (41) relop -> LT .

    ID              reduce using rule 41 (relop -> LT .)
    NUMBER          reduce using rule 41 (relop -> LT .)
    LPAREN          reduce using rule 41 (relop -> LT .)
    NOT             reduce using rule 41 (relop -> LT .)
    TRUE            reduce using rule 41 (relop -> LT .)
    FALSE           reduce using rule 41 (relop -> LT .)
    MINUS           reduce using rule 41 (relop -> LT .)


state 69

    (42) relop -> GT .

    ID              reduce using rule 42 (relop -> GT .)
    NUMBER          reduce using rule 42 (relop -> GT .)
    LPAREN          reduce using rule 42 (relop -> GT .)
    NOT             reduce using rule 42 (relop -> GT .)
    TRUE            reduce using rule 42 (relop -> GT .)
    FALSE           reduce using rule 42 (relop -> GT .)
    MINUS           reduce using rule 42 (relop -> GT .)


state 70

    (43) relop -> LE .

    ID              reduce using rule 43 (relop -> LE .)
    NUMBER          reduce using rule 43 (relop -> LE .)
    LPAREN          reduce using rule 43 (relop -> LE .)
    NOT             reduce using rule 43 (relop -> LE .)
    TRUE            reduce using rule 43 (relop -> LE .)
    FALSE           reduce using rule 43 (relop -> LE .)
    MINUS           reduce using rule 43 (relop -> LE .)


state 71

    (44) relop -> GE .

    ID              reduce using rule 44 (relop -> GE .)
    NUMBER          reduce using rule 44 (relop -> GE .)
    LPAREN          reduce using rule 44 (relop -> GE .)
    NOT             reduce using rule 44 (relop -> GE .)
    TRUE            reduce using rule 44 (relop -> GE .)
    FALSE           reduce using rule 44 (relop -> GE .)
    MINUS           reduce using rule 44 (relop -> GE .)


state 72

    (47) addop -> PLUS .

    ID              reduce using rule 47 (addop -> PLUS .)
    NUMBER          reduce using rule 47 (addop -> PLUS .)
    LPAREN          reduce using rule 47 (addop -> PLUS .)
    NOT             reduce using rule 47 (addop -> PLUS .)
    TRUE            reduce using rule 47 (addop -> PLUS .)
    FALSE           reduce using rule 47 (addop -> PLUS .)
    MINUS           reduce using rule 47 (addop -> PLUS .)


state 73

    (48) addop -> MINUS .

    ID              reduce using rule 48 (addop -> MINUS .)
    NUMBER          reduce using rule 48 (addop -> MINUS .)
    LPAREN          reduce using rule 48 (addop -> MINUS .)
    NOT             reduce using rule 48 (addop -> MINUS .)
    TRUE            reduce using rule 48 (addop -> MINUS .)
    FALSE           reduce using rule 48 (addop -> MINUS .)
    MINUS           reduce using rule 48 (addop -> MINUS .)


state 74

    (49) addop -> OR .

    ID              reduce using rule 49 (addop -> OR .)
    NUMBER          reduce using rule 49 (addop -> OR .)
    LPAREN          reduce using rule 49 (addop -> OR .)
    NOT             reduce using rule 49 (addop -> OR .)
    TRUE            reduce using rule 49 (addop -> OR .)
    FALSE           reduce using rule 49 (addop -> OR .)
    MINUS           reduce using rule 49 (addop -> OR .)


state 75

    (51) term -> term mulop . factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    factor                         shift and go to state 97

state 76

    (52) mulop -> TIMES .

    ID              reduce using rule 52 (mulop -> TIMES .)
    NUMBER          reduce using rule 52 (mulop -> TIMES .)
    LPAREN          reduce using rule 52 (mulop -> TIMES .)
    NOT             reduce using rule 52 (mulop -> TIMES .)
    TRUE            reduce using rule 52 (mulop -> TIMES .)
    FALSE           reduce using rule 52 (mulop -> TIMES .)
    MINUS           reduce using rule 52 (mulop -> TIMES .)


state 77

    (53) mulop -> DIVIDE .

    ID              reduce using rule 53 (mulop -> DIVIDE .)
    NUMBER          reduce using rule 53 (mulop -> DIVIDE .)
    LPAREN          reduce using rule 53 (mulop -> DIVIDE .)
    NOT             reduce using rule 53 (mulop -> DIVIDE .)
    TRUE            reduce using rule 53 (mulop -> DIVIDE .)
    FALSE           reduce using rule 53 (mulop -> DIVIDE .)
    MINUS           reduce using rule 53 (mulop -> DIVIDE .)


state 78

    (54) mulop -> DIV .

    ID              reduce using rule 54 (mulop -> DIV .)
    NUMBER          reduce using rule 54 (mulop -> DIV .)
    LPAREN          reduce using rule 54 (mulop -> DIV .)
    NOT             reduce using rule 54 (mulop -> DIV .)
    TRUE            reduce using rule 54 (mulop -> DIV .)
    FALSE           reduce using rule 54 (mulop -> DIV .)
    MINUS           reduce using rule 54 (mulop -> DIV .)


state 79

    (55) mulop -> MOD .

    ID              reduce using rule 55 (mulop -> MOD .)
    NUMBER          reduce using rule 55 (mulop -> MOD .)
    LPAREN          reduce using rule 55 (mulop -> MOD .)
    NOT             reduce using rule 55 (mulop -> MOD .)
    TRUE            reduce using rule 55 (mulop -> MOD .)
    FALSE           reduce using rule 55 (mulop -> MOD .)
    MINUS           reduce using rule 55 (mulop -> MOD .)


state 80

    (56) mulop -> AND .

    ID              reduce using rule 56 (mulop -> AND .)
    NUMBER          reduce using rule 56 (mulop -> AND .)
    LPAREN          reduce using rule 56 (mulop -> AND .)
    NOT             reduce using rule 56 (mulop -> AND .)
    TRUE            reduce using rule 56 (mulop -> AND .)
    FALSE           reduce using rule 56 (mulop -> AND .)
    MINUS           reduce using rule 56 (mulop -> AND .)


state 81

    (59) factor -> LPAREN expr . RPAREN

    RPAREN          shift and go to state 98


state 82

    (60) factor -> NOT factor .

    TIMES           reduce using rule 60 (factor -> NOT factor .)
    DIVIDE          reduce using rule 60 (factor -> NOT factor .)
    DIV             reduce using rule 60 (factor -> NOT factor .)
    MOD             reduce using rule 60 (factor -> NOT factor .)
    AND             reduce using rule 60 (factor -> NOT factor .)
    EQUAL           reduce using rule 60 (factor -> NOT factor .)
    NOTEQUAL        reduce using rule 60 (factor -> NOT factor .)
    LT              reduce using rule 60 (factor -> NOT factor .)
    GT              reduce using rule 60 (factor -> NOT factor .)
    LE              reduce using rule 60 (factor -> NOT factor .)
    GE              reduce using rule 60 (factor -> NOT factor .)
    PLUS            reduce using rule 60 (factor -> NOT factor .)
    MINUS           reduce using rule 60 (factor -> NOT factor .)
    OR              reduce using rule 60 (factor -> NOT factor .)
    THEN            reduce using rule 60 (factor -> NOT factor .)
    DO              reduce using rule 60 (factor -> NOT factor .)
    SEMI            reduce using rule 60 (factor -> NOT factor .)
    END             reduce using rule 60 (factor -> NOT factor .)
    ELSE            reduce using rule 60 (factor -> NOT factor .)
    RPAREN          reduce using rule 60 (factor -> NOT factor .)
    COMMA           reduce using rule 60 (factor -> NOT factor .)
    TO              reduce using rule 60 (factor -> NOT factor .)


state 83

    (63) factor -> MINUS factor .

    TIMES           reduce using rule 63 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 63 (factor -> MINUS factor .)
    DIV             reduce using rule 63 (factor -> MINUS factor .)
    MOD             reduce using rule 63 (factor -> MINUS factor .)
    AND             reduce using rule 63 (factor -> MINUS factor .)
    EQUAL           reduce using rule 63 (factor -> MINUS factor .)
    NOTEQUAL        reduce using rule 63 (factor -> MINUS factor .)
    LT              reduce using rule 63 (factor -> MINUS factor .)
    GT              reduce using rule 63 (factor -> MINUS factor .)
    LE              reduce using rule 63 (factor -> MINUS factor .)
    GE              reduce using rule 63 (factor -> MINUS factor .)
    PLUS            reduce using rule 63 (factor -> MINUS factor .)
    MINUS           reduce using rule 63 (factor -> MINUS factor .)
    OR              reduce using rule 63 (factor -> MINUS factor .)
    THEN            reduce using rule 63 (factor -> MINUS factor .)
    DO              reduce using rule 63 (factor -> MINUS factor .)
    SEMI            reduce using rule 63 (factor -> MINUS factor .)
    END             reduce using rule 63 (factor -> MINUS factor .)
    ELSE            reduce using rule 63 (factor -> MINUS factor .)
    RPAREN          reduce using rule 63 (factor -> MINUS factor .)
    COMMA           reduce using rule 63 (factor -> MINUS factor .)
    TO              reduce using rule 63 (factor -> MINUS factor .)


state 84

    (26) while_stmt -> WHILE expr DO . stmt
    (15) stmt -> . assignment
    (16) stmt -> . if_stmt
    (17) stmt -> . while_stmt
    (18) stmt -> . for_stmt
    (19) stmt -> . readln_stmt
    (20) stmt -> . writeln_stmt
    (21) stmt -> . compound_stmt
    (22) stmt -> . empty
    (23) assignment -> . ID ASSIGN expr
    (24) if_stmt -> . IF expr THEN stmt
    (25) if_stmt -> . IF expr THEN stmt ELSE stmt
    (26) while_stmt -> . WHILE expr DO stmt
    (27) for_stmt -> . FOR ID ASSIGN expr TO expr DO stmt
    (28) readln_stmt -> . READLN LPAREN ID RPAREN
    (29) writeln_stmt -> . WRITELN LPAREN writeln_args RPAREN
    (30) writeln_stmt -> . WRITE LPAREN writeln_args RPAREN
    (31) writeln_stmt -> . WRITELN LPAREN RPAREN
    (32) writeln_stmt -> . WRITE LPAREN RPAREN
    (12) compound_stmt -> . BEGIN stmt_list END
    (64) empty -> .

    ID              shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    READLN          shift and go to state 30
    WRITELN         shift and go to state 31
    WRITE           shift and go to state 32
    BEGIN           shift and go to state 9
    ELSE            reduce using rule 64 (empty -> .)
    SEMI            reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)

    stmt                           shift and go to state 99
    assignment                     shift and go to state 18
    if_stmt                        shift and go to state 19
    while_stmt                     shift and go to state 20
    for_stmt                       shift and go to state 21
    readln_stmt                    shift and go to state 22
    writeln_stmt                   shift and go to state 23
    compound_stmt                  shift and go to state 24
    empty                          shift and go to state 25

state 85

    (27) for_stmt -> FOR ID ASSIGN . expr TO expr DO stmt
    (37) expr -> . simple_expr
    (38) expr -> . simple_expr relop simple_expr
    (45) simple_expr -> . term
    (46) simple_expr -> . simple_expr addop term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    expr                           shift and go to state 100
    simple_expr                    shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 86

    (28) readln_stmt -> READLN LPAREN ID . RPAREN

    RPAREN          shift and go to state 101


state 87

    (29) writeln_stmt -> WRITELN LPAREN writeln_args . RPAREN

    RPAREN          shift and go to state 102


state 88

    (31) writeln_stmt -> WRITELN LPAREN RPAREN .

    SEMI            reduce using rule 31 (writeln_stmt -> WRITELN LPAREN RPAREN .)
    END             reduce using rule 31 (writeln_stmt -> WRITELN LPAREN RPAREN .)
    ELSE            reduce using rule 31 (writeln_stmt -> WRITELN LPAREN RPAREN .)


state 89

    (33) writeln_args -> arg .
    (34) writeln_args -> arg . COMMA writeln_args

    RPAREN          reduce using rule 33 (writeln_args -> arg .)
    COMMA           shift and go to state 103


state 90

    (35) arg -> expr .

    COMMA           reduce using rule 35 (arg -> expr .)
    RPAREN          reduce using rule 35 (arg -> expr .)


state 91

    (36) arg -> STRING .

    COMMA           reduce using rule 36 (arg -> STRING .)
    RPAREN          reduce using rule 36 (arg -> STRING .)


state 92

    (30) writeln_stmt -> WRITE LPAREN writeln_args . RPAREN

    RPAREN          shift and go to state 104


state 93

    (32) writeln_stmt -> WRITE LPAREN RPAREN .

    SEMI            reduce using rule 32 (writeln_stmt -> WRITE LPAREN RPAREN .)
    END             reduce using rule 32 (writeln_stmt -> WRITE LPAREN RPAREN .)
    ELSE            reduce using rule 32 (writeln_stmt -> WRITE LPAREN RPAREN .)


state 94

    (24) if_stmt -> IF expr THEN stmt .
    (25) if_stmt -> IF expr THEN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    SEMI            reduce using rule 24 (if_stmt -> IF expr THEN stmt .)
    END             reduce using rule 24 (if_stmt -> IF expr THEN stmt .)
    ELSE            shift and go to state 105

  ! ELSE            [ reduce using rule 24 (if_stmt -> IF expr THEN stmt .) ]


state 95

    (38) expr -> simple_expr relop simple_expr .
    (46) simple_expr -> simple_expr . addop term
    (47) addop -> . PLUS
    (48) addop -> . MINUS
    (49) addop -> . OR

    THEN            reduce using rule 38 (expr -> simple_expr relop simple_expr .)
    DO              reduce using rule 38 (expr -> simple_expr relop simple_expr .)
    SEMI            reduce using rule 38 (expr -> simple_expr relop simple_expr .)
    END             reduce using rule 38 (expr -> simple_expr relop simple_expr .)
    ELSE            reduce using rule 38 (expr -> simple_expr relop simple_expr .)
    RPAREN          reduce using rule 38 (expr -> simple_expr relop simple_expr .)
    COMMA           reduce using rule 38 (expr -> simple_expr relop simple_expr .)
    TO              reduce using rule 38 (expr -> simple_expr relop simple_expr .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73
    OR              shift and go to state 74

    addop                          shift and go to state 65

state 96

    (46) simple_expr -> simple_expr addop term .
    (51) term -> term . mulop factor
    (52) mulop -> . TIMES
    (53) mulop -> . DIVIDE
    (54) mulop -> . DIV
    (55) mulop -> . MOD
    (56) mulop -> . AND

    EQUAL           reduce using rule 46 (simple_expr -> simple_expr addop term .)
    NOTEQUAL        reduce using rule 46 (simple_expr -> simple_expr addop term .)
    LT              reduce using rule 46 (simple_expr -> simple_expr addop term .)
    GT              reduce using rule 46 (simple_expr -> simple_expr addop term .)
    LE              reduce using rule 46 (simple_expr -> simple_expr addop term .)
    GE              reduce using rule 46 (simple_expr -> simple_expr addop term .)
    PLUS            reduce using rule 46 (simple_expr -> simple_expr addop term .)
    MINUS           reduce using rule 46 (simple_expr -> simple_expr addop term .)
    OR              reduce using rule 46 (simple_expr -> simple_expr addop term .)
    THEN            reduce using rule 46 (simple_expr -> simple_expr addop term .)
    DO              reduce using rule 46 (simple_expr -> simple_expr addop term .)
    SEMI            reduce using rule 46 (simple_expr -> simple_expr addop term .)
    END             reduce using rule 46 (simple_expr -> simple_expr addop term .)
    ELSE            reduce using rule 46 (simple_expr -> simple_expr addop term .)
    RPAREN          reduce using rule 46 (simple_expr -> simple_expr addop term .)
    COMMA           reduce using rule 46 (simple_expr -> simple_expr addop term .)
    TO              reduce using rule 46 (simple_expr -> simple_expr addop term .)
    TIMES           shift and go to state 76
    DIVIDE          shift and go to state 77
    DIV             shift and go to state 78
    MOD             shift and go to state 79
    AND             shift and go to state 80

    mulop                          shift and go to state 75

state 97

    (51) term -> term mulop factor .

    TIMES           reduce using rule 51 (term -> term mulop factor .)
    DIVIDE          reduce using rule 51 (term -> term mulop factor .)
    DIV             reduce using rule 51 (term -> term mulop factor .)
    MOD             reduce using rule 51 (term -> term mulop factor .)
    AND             reduce using rule 51 (term -> term mulop factor .)
    EQUAL           reduce using rule 51 (term -> term mulop factor .)
    NOTEQUAL        reduce using rule 51 (term -> term mulop factor .)
    LT              reduce using rule 51 (term -> term mulop factor .)
    GT              reduce using rule 51 (term -> term mulop factor .)
    LE              reduce using rule 51 (term -> term mulop factor .)
    GE              reduce using rule 51 (term -> term mulop factor .)
    PLUS            reduce using rule 51 (term -> term mulop factor .)
    MINUS           reduce using rule 51 (term -> term mulop factor .)
    OR              reduce using rule 51 (term -> term mulop factor .)
    THEN            reduce using rule 51 (term -> term mulop factor .)
    DO              reduce using rule 51 (term -> term mulop factor .)
    SEMI            reduce using rule 51 (term -> term mulop factor .)
    END             reduce using rule 51 (term -> term mulop factor .)
    ELSE            reduce using rule 51 (term -> term mulop factor .)
    RPAREN          reduce using rule 51 (term -> term mulop factor .)
    COMMA           reduce using rule 51 (term -> term mulop factor .)
    TO              reduce using rule 51 (term -> term mulop factor .)


state 98

    (59) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    DIV             reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    MOD             reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    NOTEQUAL        reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    THEN            reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    DO              reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    END             reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    ELSE            reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 59 (factor -> LPAREN expr RPAREN .)
    TO              reduce using rule 59 (factor -> LPAREN expr RPAREN .)


state 99

    (26) while_stmt -> WHILE expr DO stmt .

    SEMI            reduce using rule 26 (while_stmt -> WHILE expr DO stmt .)
    END             reduce using rule 26 (while_stmt -> WHILE expr DO stmt .)
    ELSE            reduce using rule 26 (while_stmt -> WHILE expr DO stmt .)


state 100

    (27) for_stmt -> FOR ID ASSIGN expr . TO expr DO stmt

    TO              shift and go to state 106


state 101

    (28) readln_stmt -> READLN LPAREN ID RPAREN .

    SEMI            reduce using rule 28 (readln_stmt -> READLN LPAREN ID RPAREN .)
    END             reduce using rule 28 (readln_stmt -> READLN LPAREN ID RPAREN .)
    ELSE            reduce using rule 28 (readln_stmt -> READLN LPAREN ID RPAREN .)


state 102

    (29) writeln_stmt -> WRITELN LPAREN writeln_args RPAREN .

    SEMI            reduce using rule 29 (writeln_stmt -> WRITELN LPAREN writeln_args RPAREN .)
    END             reduce using rule 29 (writeln_stmt -> WRITELN LPAREN writeln_args RPAREN .)
    ELSE            reduce using rule 29 (writeln_stmt -> WRITELN LPAREN writeln_args RPAREN .)


state 103

    (34) writeln_args -> arg COMMA . writeln_args
    (33) writeln_args -> . arg
    (34) writeln_args -> . arg COMMA writeln_args
    (35) arg -> . expr
    (36) arg -> . STRING
    (37) expr -> . simple_expr
    (38) expr -> . simple_expr relop simple_expr
    (45) simple_expr -> . term
    (46) simple_expr -> . simple_expr addop term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    STRING          shift and go to state 91
    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    arg                            shift and go to state 89
    writeln_args                   shift and go to state 107
    expr                           shift and go to state 90
    simple_expr                    shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 104

    (30) writeln_stmt -> WRITE LPAREN writeln_args RPAREN .

    SEMI            reduce using rule 30 (writeln_stmt -> WRITE LPAREN writeln_args RPAREN .)
    END             reduce using rule 30 (writeln_stmt -> WRITE LPAREN writeln_args RPAREN .)
    ELSE            reduce using rule 30 (writeln_stmt -> WRITE LPAREN writeln_args RPAREN .)


state 105

    (25) if_stmt -> IF expr THEN stmt ELSE . stmt
    (15) stmt -> . assignment
    (16) stmt -> . if_stmt
    (17) stmt -> . while_stmt
    (18) stmt -> . for_stmt
    (19) stmt -> . readln_stmt
    (20) stmt -> . writeln_stmt
    (21) stmt -> . compound_stmt
    (22) stmt -> . empty
    (23) assignment -> . ID ASSIGN expr
    (24) if_stmt -> . IF expr THEN stmt
    (25) if_stmt -> . IF expr THEN stmt ELSE stmt
    (26) while_stmt -> . WHILE expr DO stmt
    (27) for_stmt -> . FOR ID ASSIGN expr TO expr DO stmt
    (28) readln_stmt -> . READLN LPAREN ID RPAREN
    (29) writeln_stmt -> . WRITELN LPAREN writeln_args RPAREN
    (30) writeln_stmt -> . WRITE LPAREN writeln_args RPAREN
    (31) writeln_stmt -> . WRITELN LPAREN RPAREN
    (32) writeln_stmt -> . WRITE LPAREN RPAREN
    (12) compound_stmt -> . BEGIN stmt_list END
    (64) empty -> .

    ID              shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    READLN          shift and go to state 30
    WRITELN         shift and go to state 31
    WRITE           shift and go to state 32
    BEGIN           shift and go to state 9
    ELSE            reduce using rule 64 (empty -> .)
    SEMI            reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)

    stmt                           shift and go to state 108
    assignment                     shift and go to state 18
    if_stmt                        shift and go to state 19
    while_stmt                     shift and go to state 20
    for_stmt                       shift and go to state 21
    readln_stmt                    shift and go to state 22
    writeln_stmt                   shift and go to state 23
    compound_stmt                  shift and go to state 24
    empty                          shift and go to state 25

state 106

    (27) for_stmt -> FOR ID ASSIGN expr TO . expr DO stmt
    (37) expr -> . simple_expr
    (38) expr -> . simple_expr relop simple_expr
    (45) simple_expr -> . term
    (46) simple_expr -> . simple_expr addop term
    (50) term -> . factor
    (51) term -> . term mulop factor
    (57) factor -> . ID
    (58) factor -> . NUMBER
    (59) factor -> . LPAREN expr RPAREN
    (60) factor -> . NOT factor
    (61) factor -> . TRUE
    (62) factor -> . FALSE
    (63) factor -> . MINUS factor

    ID              shift and go to state 44
    NUMBER          shift and go to state 45
    LPAREN          shift and go to state 46
    NOT             shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    MINUS           shift and go to state 50

    expr                           shift and go to state 109
    simple_expr                    shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 43

state 107

    (34) writeln_args -> arg COMMA writeln_args .

    RPAREN          reduce using rule 34 (writeln_args -> arg COMMA writeln_args .)


state 108

    (25) if_stmt -> IF expr THEN stmt ELSE stmt .

    SEMI            reduce using rule 25 (if_stmt -> IF expr THEN stmt ELSE stmt .)
    END             reduce using rule 25 (if_stmt -> IF expr THEN stmt ELSE stmt .)
    ELSE            reduce using rule 25 (if_stmt -> IF expr THEN stmt ELSE stmt .)


state 109

    (27) for_stmt -> FOR ID ASSIGN expr TO expr . DO stmt

    DO              shift and go to state 110


state 110

    (27) for_stmt -> FOR ID ASSIGN expr TO expr DO . stmt
    (15) stmt -> . assignment
    (16) stmt -> . if_stmt
    (17) stmt -> . while_stmt
    (18) stmt -> . for_stmt
    (19) stmt -> . readln_stmt
    (20) stmt -> . writeln_stmt
    (21) stmt -> . compound_stmt
    (22) stmt -> . empty
    (23) assignment -> . ID ASSIGN expr
    (24) if_stmt -> . IF expr THEN stmt
    (25) if_stmt -> . IF expr THEN stmt ELSE stmt
    (26) while_stmt -> . WHILE expr DO stmt
    (27) for_stmt -> . FOR ID ASSIGN expr TO expr DO stmt
    (28) readln_stmt -> . READLN LPAREN ID RPAREN
    (29) writeln_stmt -> . WRITELN LPAREN writeln_args RPAREN
    (30) writeln_stmt -> . WRITE LPAREN writeln_args RPAREN
    (31) writeln_stmt -> . WRITELN LPAREN RPAREN
    (32) writeln_stmt -> . WRITE LPAREN RPAREN
    (12) compound_stmt -> . BEGIN stmt_list END
    (64) empty -> .

    ID              shift and go to state 26
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    READLN          shift and go to state 30
    WRITELN         shift and go to state 31
    WRITE           shift and go to state 32
    BEGIN           shift and go to state 9
    ELSE            reduce using rule 64 (empty -> .)
    SEMI            reduce using rule 64 (empty -> .)
    END             reduce using rule 64 (empty -> .)

    stmt                           shift and go to state 111
    assignment                     shift and go to state 18
    if_stmt                        shift and go to state 19
    while_stmt                     shift and go to state 20
    for_stmt                       shift and go to state 21
    readln_stmt                    shift and go to state 22
    writeln_stmt                   shift and go to state 23
    compound_stmt                  shift and go to state 24
    empty                          shift and go to state 25

state 111

    (27) for_stmt -> FOR ID ASSIGN expr TO expr DO stmt .

    SEMI            reduce using rule 27 (for_stmt -> FOR ID ASSIGN expr TO expr DO stmt .)
    END             reduce using rule 27 (for_stmt -> FOR ID ASSIGN expr TO expr DO stmt .)
    ELSE            reduce using rule 27 (for_stmt -> FOR ID ASSIGN expr TO expr DO stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for BEGIN in state 4 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 94 resolved as shift
